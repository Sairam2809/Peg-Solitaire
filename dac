import tkinter as tk
from tkinter import messagebox
import threading
import time

# ======================================================================
# BoardGraph
# ======================================================================
class BoardGraph:
    def __init__(self, version="english"):
        self.version = version
        self.nodes = []
        self.node_to_id = {}
        self.adj_matrix = []
        self.valid_jumps = []
        self._build_board_layout()
        self._build_adjacency_matrix()
        self._precompute_jumps()

    def _build_board_layout(self):
        if self.version == "english":
            layout = [
                "  XXX ",
                "  XXX ",
                "XXXXXXX",
                "XXXXXXX",
                "XXXXXXX",
                "  XXX ",
                "  XXX "
            ]
        else:  # european
            layout = [
                "  XXX ",
                " XXXXX ",
                "XXXXXXX",
                "XXXXXXX",
                "XXXXXXX",
                " XXXXX ",
                "  XXX "
            ]
        for r, row_str in enumerate(layout):
            for c, char in enumerate(row_str):
                if char == 'X':
                    self.node_to_id[(r, c)] = len(self.nodes)
                    self.nodes.append((r, c))

    def _build_adjacency_matrix(self):
        n = len(self.nodes)
        self.adj_matrix = [[0]*n for _ in range(n)]
        for i in range(n):
            r1, c1 = self.nodes[i]
            for j in range(i+1, n):
                r2, c2 = self.nodes[j]
                if abs(r1-r2)+abs(c1-c2) == 1:
                    self.adj_matrix[i][j] = 1
                    self.adj_matrix[j][i] = 1

    def _precompute_jumps(self):
        n = len(self.nodes)
        directions = [(-1,0),(1,0),(0,-1),(0,1)]
        for i in range(n):
            r,c = self.nodes[i]
            for dr,dc in directions:
                mr,mc = r+dr, c+dc
                er,ec = r+2*dr, c+2*dc
                if (mr,mc) in self.node_to_id and (er,ec) in self.node_to_id:
                    self.valid_jumps.append((i, self.node_to_id[(mr,mc)], self.node_to_id[(er,ec)]))

# ======================================================================
# GameState 
# ======================================================================
class GameState:
    def __init__(self, graph):
        self.graph = graph
        self.pegs = [1]*len(graph.nodes)
        self.history = []
        centre = (3,3)
        if centre in graph.node_to_id:
            self.pegs[graph.node_to_id[centre]] = 0

    def get_legal_moves(self):
        moves = []
        for s,m,e in self.graph.valid_jumps:
            if self.pegs[s]==1 and self.pegs[m]==1 and self.pegs[e]==0:
                moves.append((s,m,e))
        return moves

    def execute_move(self, move):
        s,m,e = move
        self.history.append(self.pegs[:])
        self.pegs[s]=0; self.pegs[m]=0; self.pegs[e]=1

    def undo(self):
        if self.history:
            self.pegs = self.history.pop()
            return True
        return False

    def get_peg_count(self):
        return sum(self.pegs)

    def is_game_over(self):
        return len(self.get_legal_moves()) == 0

# ======================================================================
# DIVIDEâ€‘ANDâ€‘CONQUER SOLVER 
# ======================================================================
class RegionShrinkingDCSolver:
    """
    Region Shrinking / Central Expansion Solver (Pure Divide & Conquer).

    Strategy:
      - Inherits the Divide & Conquer structure (Spatial Splitting).
      - Enhances the 'Conquer' and 'Combine' phases with a Priority Heuristic.
      - PRIORITY: Linearly scan for valid moves, but execute them in an order
                  that effectively 'shrinks' the board from the outside in.
                  Priority = Distance of the removed peg (middle peg) from center.
                  Outer pegs are removed first.

    Algorithm:
      1. DIVIDE  : Partition the board spatially into two halves.
      2. CONQUER : Recursively process each half.
                   In base cases (small regions), moves are executed based on Priority.
      3. COMBINE : Execute cross-boundary moves, also sorted by Priority.

    No undo() is ever called (No Backtracking).
    """

    def __init__(self, game_state):
        self.game = game_state
        self.solution_cache = None
        self.search_thread = None
        self.search_cancel = False
        self.callback = None

    # ---- threading helpers ------------------------------------------------
    def start_solving(self, callback):
        """Run the D&C search in a background thread."""
        self.cancel_solving()
        self.search_cancel = False
        self.callback = callback
        self.search_thread = threading.Thread(target=self._threaded_search)
        self.search_thread.daemon = True
        self.search_thread.start()

    def _threaded_search(self):
        # Work on a COPY of the peg state so the UI board is untouched
        pegs = self.game.pegs[:]
        all_nodes = list(range(len(self.game.graph.nodes)))
        solution = self._solve_dc(all_nodes, pegs, split_by_row=True)
        if self.search_cancel:
            solution = None
        if self.callback:
            self.game_frame.after(0, self.callback, solution if solution else None)

    # ---- divide & conquer -------------------------------------------
    def _solve_dc(self, node_indices, pegs, split_by_row=True):
        """
        Pure D&C entry point.

        Args:
            node_indices : list of node IDs in the current region
            pegs         : mutable list[int] of peg states (0/1)
            split_by_row : True â†’ split by row; False â†’ by column

        Returns:
            List of (start, mid, end) move tuples that were executed.
        """
        if self.search_cancel:
            return []

        # â”€â”€ BASE CASE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Region is too small to sub-divide: greedily execute moves BY PRIORITY.
        if len(node_indices) <= 3:
            return self._solve_small_region_priority(node_indices, pegs)

        # â”€â”€ DIVIDE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Split the region spatially into two halves.
        left_half, right_half = self._spatial_split(node_indices, split_by_row)

        # â”€â”€ CONQUER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Recursively solve each sub-region (alternate the split axis).
        left_moves  = self._solve_dc(left_half,  pegs, not split_by_row)
        right_moves = self._solve_dc(right_half, pegs, not split_by_row)

        # â”€â”€ COMBINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # Execute cross-boundary moves between the two halves BY PRIORITY.
        cross_moves = self._execute_cross_boundary_moves_priority(
            left_half, right_half, pegs
        )

        return left_moves + right_moves + cross_moves

    # ---- Region Shrinking Heuristics --------------------------------------
    def _get_move_priority(self, move):
        """
        Calculate priority for a move (s, m, e).
        Higher priority = removing pegs further from center (Region Shrinking).
        Center is approx (3,3).
        """
        s, m, e = move
        # Get coordinates of the middle peg (the one being removed)
        r_m, c_m = self.game.graph.nodes[m]
        # Get coordinates of the start peg (the one moving)
        r_s, c_s = self.game.graph.nodes[s]
        
        # Distance from center (3,3)
        dist_m = abs(r_m - 3) + abs(c_m - 3)
        dist_s = abs(r_s - 3) + abs(c_s - 3)

        # Priority:
        # 1. Primary: Distance of removed peg (m). Remove outer pegs first!
        # 2. Secondary: Distance of start peg (s). Move outer pegs inward!
        return (dist_m * 10) + dist_s

    def _solve_small_region_priority(self, node_indices, pegs):
        """Greedily execute moves in region, prioritizing Region Shrinking."""
        region_set = set(node_indices)
        moves_made = []
        changed = True
        
        while changed:
            changed = False
            candidate_moves = []

            # 1. Collect all legal moves entirely within this region
            for s, m, e in self.game.graph.valid_jumps:
                if s in region_set and m in region_set and e in region_set:
                    if pegs[s] == 1 and pegs[m] == 1 and pegs[e] == 0:
                        priority = self._get_move_priority((s, m, e))
                        candidate_moves.append((priority, (s, m, e)))
            
            # 2. Sort by priority (descending)
            candidate_moves.sort(key=lambda x: x[0], reverse=True)

            # 3. Execute the best move
            if candidate_moves:
                _, best_move = candidate_moves[0]
                s, m, e = best_move
                pegs[s] = 0; pegs[m] = 0; pegs[e] = 1
                moves_made.append((s, m, e))
                changed = True

        return moves_made

    def _execute_cross_boundary_moves_priority(self, left, right, pegs):
        """Execute cross-boundary moves, prioritizing Region Shrinking."""
        left_set  = set(left)
        right_set = set(right)
        all_set   = left_set | right_set
        moves_made = []
        changed = True

        while changed:
            changed = False
            candidate_moves = []

            # 1. Collect all legal moves spanning the boundary
            for s, m, e in self.game.graph.valid_jumps:
                if s in all_set and m in all_set and e in all_set:
                    involved = {s, m, e}
                    if involved & left_set and involved & right_set:
                        if pegs[s] == 1 and pegs[m] == 1 and pegs[e] == 0:
                            priority = self._get_move_priority((s, m, e))
                            candidate_moves.append((priority, (s, m, e)))

            # 2. Sort by priority (descending)
            candidate_moves.sort(key=lambda x: x[0], reverse=True)

            # 3. Execute the best move
            if candidate_moves:
                _, best_move = candidate_moves[0]
                s, m, e = best_move
                pegs[s] = 0; pegs[m] = 0; pegs[e] = 1
                moves_made.append((s, m, e))
                changed = True
                
        return moves_made

    # ---- helpers ----------------------------------------------------------
    def _spatial_split(self, node_indices, by_row):
        """Split nodes into two halves based on spatial position."""
        key = ((lambda i: self.game.graph.nodes[i][0]) if by_row
               else (lambda i: self.game.graph.nodes[i][1]))
        sorted_nodes = sorted(node_indices, key=key)
        mid = len(sorted_nodes) // 2
        return sorted_nodes[:mid], sorted_nodes[mid:]

    def cancel_solving(self):
        self.search_cancel = True
        if self.search_thread and self.search_thread.is_alive():
            self.search_thread.join(timeout=0.1)
        self.search_thread = None

    def get_hint_move(self):
        return self.solution_cache[0] if self.solution_cache else None

    def get_full_solution(self):
        return self.solution_cache

# ======================================================================
# UI 
# ======================================================================
class PegSolitaireApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Region Shrinking Strategy (Pure Divide & Conquer)")
        self.root.geometry("600x700")
        self.root.configure(bg="#f0f0f0")
        self.current_frame = None
        self.show_main_menu()

    def clear_window(self):
        if self.current_frame:
            self.current_frame.destroy()

    def show_main_menu(self):
        self.clear_window()
        self.current_frame = tk.Frame(self.root, bg="#f0f0f0")
        self.current_frame.pack(fill="both", expand=True)
        tk.Label(self.current_frame, text="Peg Solitaire", font=("Helvetica",32,"bold"),
                 bg="#f0f0f0", fg="#333").pack(pady=50)
        tk.Button(self.current_frame, text="English Version", font=("Helvetica",16), width=20, bg="#ed2b08",
                  command=lambda: self.start_game("english")).pack(pady=10)
        tk.Button(self.current_frame, text="European Version", font=("Helvetica",16), width=20, bg="#0e0ee3",
                  command=lambda: self.start_game("european")).pack(pady=10)
        tk.Button(self.current_frame, text="Exit", font=("Helvetica",16), width=20, bg="#06f516",
                  command=self.root.quit).pack(pady=30)

    def start_game(self, version):
        self.clear_window()
        self.current_frame = GameFrame(self.root, version, self.show_main_menu)
        self.current_frame.pack(fill="both", expand=True)

class GameFrame(tk.Frame):
    def __init__(self, parent, version, on_back):
        super().__init__(parent, bg="#2c3e50")
        self.version = version
        self.on_back = on_back

        self.graph = BoardGraph(version)
        self.game = GameState(self.graph)
        self.solver = RegionShrinkingDCSolver(self.game)
        self.solver.game_frame = self

        self.selected_node = None
        self.autoplay_running = False
        self.autoplay_moves = []
        self.autoplay_index = 0
        self.searching = False

        self._setup_ui()
        self.draw_board()

    def _setup_ui(self):
        # Top Bar
        self.top_bar = tk.Frame(self, bg="#34495e", height=50)
        self.top_bar.pack(fill="x")
        self.lbl_info = tk.Label(self.top_bar, text="Pegs: 32", font=("Arial",14,"bold"),
                                 bg="#34495e", fg="white")
        self.lbl_info.pack(side="left", padx=20, pady=10)
        self.btn_menu = tk.Button(self.top_bar, text="Main Menu", command=self.on_exit,
                                  bg="#e74c3c", fg="white")
        self.btn_menu.pack(side="right", padx=10, pady=10)

        # Canvas
        self.canvas = tk.Canvas(self, bg="#2c3e50", highlightthickness=0)
        self.canvas.pack(fill="both", expand=True, padx=20, pady=20)
        self.canvas.bind("<Button-1>", self.on_click)

        # Bottom Controls
        self.controls = tk.Frame(self, bg="#34495e", height=60)
        self.controls.pack(fill="x", side="bottom")
        btn_style = {"font": ("Arial",12), "width":10, "bg":"#ecf0f1"}

        tk.Button(self.controls, text="Undo", command=self.undo_move, **btn_style).pack(side="left", padx=10, pady=10)
        tk.Button(self.controls, text="Restart", command=self.restart_game, **btn_style).pack(side="left", padx=10, pady=10)
        tk.Frame(self.controls, width=30, bg="#34495e").pack(side="left")
        tk.Button(self.controls, text="Hint", command=self.show_hint, **btn_style).pack(side="left", padx=10, pady=10)
        self.btn_auto = tk.Button(self.controls, text="Autoplay", command=self.toggle_autoplay, **btn_style)
        self.btn_auto.pack(side="left", padx=10, pady=10)

        # Status label
        self.lbl_status = tk.Label(self.controls, text="", font=("Arial",10), bg="#34495e", fg="yellow")
        self.lbl_status.pack(side="right", padx=20)

    def draw_board(self):
        self.canvas.delete("all")
        width = self.canvas.winfo_width()
        height = self.canvas.winfo_height()
        if width < 10: width = 600
        if height < 10: height = 500
        rows, cols = 7, 7
        cell_size = min(width, height)//(rows+1)
        offset_x = (width - cols*cell_size)//2
        offset_y = (height - rows*cell_size)//2
        self.node_centers = {}
        for idx in range(len(self.graph.nodes)):
            r,c = self.graph.nodes[idx]
            x = offset_x + c*cell_size + cell_size//2
            y = offset_y + r*cell_size + cell_size//2
            self.node_centers[idx] = (x,y)
            radius = cell_size//3
            if self.game.pegs[idx] == 0:
                color = "#95a5a6"
            else:
                color = "#f10f0f"
                if idx == self.selected_node:
                    color = "#3b7ec0"
            self.canvas.create_oval(x-radius, y-radius, x+radius, y+radius,
                                    fill=color, outline="#7f8c8d", width=2)
        self.lbl_info.config(text=f"Pegs: {self.game.get_peg_count()}")
        if self.game.is_game_over():
            self.show_game_over()

    def show_game_over(self):
        count = self.game.get_peg_count()
        msg = f"Game Over! Pegs left: {count}"
        if count == 1:
            msg += "\nðŸŽ‰ YOU WON! ðŸŽ‰"
        w,h = self.canvas.winfo_width(), self.canvas.winfo_height()
        self.canvas.create_rectangle(0, h//2-40, w, h//2+40, fill="black", stipple="gray50")
        self.canvas.create_text(w//2, h//2, text=msg, fill="white", font=("Arial",20,"bold"))

    def on_click(self, event):
        if self.autoplay_running or self.searching:
            return
        clicked = None
        for idx, (cx,cy) in self.node_centers.items():
            if (event.x-cx)**2 + (event.y-cy)**2 < 900:
                clicked = idx
                break
        if clicked is None:
            return
        if self.selected_node is None:
            if self.game.pegs[clicked]:
                self.selected_node = clicked
                self.draw_board()
        else:
            target = clicked
            if target == self.selected_node:
                self.selected_node = None
                self.draw_board()
            elif self.game.pegs[target]==0:
                move = None
                for s,m,e in self.game.get_legal_moves():
                    if s==self.selected_node and e==target:
                        move = (s,m,e)
                        break
                if move:
                    self.game.execute_move(move)
                    self.selected_node = None
                    self.draw_board()
                    # Recreate solver for new state
                    self.solver = RegionShrinkingDCSolver(self.game)
                    self.solver.game_frame = self
                else:
                    messagebox.showwarning("Invalid","Not a legal jump")
            else:
                self.selected_node = target
                self.draw_board()

    def undo_move(self):
        if self.autoplay_running or self.searching:
            return
        if self.game.undo():
            self.selected_node = None
            self.draw_board()
            self.solver = RegionShrinkingDCSolver(self.game)
            self.solver.game_frame = self

    def restart_game(self):
        self.autoplay_running = False
        self.searching = False
        self.btn_auto.config(text="Autoplay")
        self.game = GameState(self.graph)
        self.solver = RegionShrinkingDCSolver(self.game)
        self.solver.game_frame = self
        self.selected_node = None
        self.draw_board()
        self.lbl_status.config(text="")

    def on_exit(self):
        self.autoplay_running = False
        self.searching = False
        self.solver.cancel_solving()
        self.on_back()

    def show_hint(self):
        if self.autoplay_running or self.searching:
            return
        self.searching = True
        self.lbl_status.config(text="Searching for solution...")
        self.solver.start_solving(callback=self._on_hint_solution)

    def _on_hint_solution(self, solution):
        self.searching = False
        self.lbl_status.config(text="")
        if solution:
            self.solver.solution_cache = solution
            move = solution[0]
            sx,sy = self.node_centers[move[0]]
            ex,ey = self.node_centers[move[2]]
            self.canvas.create_line(sx,sy,ex,ey, fill="#2ecc71", width=5, arrow=tk.LAST)
        else:
            messagebox.showinfo("Hint","No winning solution from this position.")

    def toggle_autoplay(self):
        if self.autoplay_running:
            self.autoplay_running = False
            self.btn_auto.config(text="Autoplay")
            self.solver.cancel_solving()
            self.lbl_status.config(text="")
            return
        if self.searching:
            return
        self.searching = True
        self.lbl_status.config(text="Computing full solution...")
        self.solver.start_solving(callback=self._on_autoplay_solution)

    def _on_autoplay_solution(self, solution):
        self.searching = False
        self.lbl_status.config(text="")
        if solution:
            self.autoplay_moves = solution
            self.autoplay_index = 0
            self.autoplay_running = True
            self.btn_auto.config(text="Stop Auto")
            self.run_autoplay_step()
        else:
            # If search returns no moves, check if we actually finished the game
            remaining = self.game.get_peg_count()
            if remaining == 1:
                # Victory! Handled by normal status update or game over check
                self.lbl_status.config(text="Solved!")
                self.autoplay_running = False
                self.btn_auto.config(text="Autoplay")
            else:
                messagebox.showinfo("Autoplay",
                    f"D&C strategy stuck â€“ no more moves found.\n({remaining} pegs remain)")
                self.autoplay_running = False
                self.btn_auto.config(text="Autoplay")

    def run_autoplay_step(self):
        if not self.autoplay_running:
            return
        if self.autoplay_index >= len(self.autoplay_moves):
            # Batch finished. Check if game is over
            if self.game.is_game_over():
                self.autoplay_running = False
                self.btn_auto.config(text="Autoplay")
                remaining = self.game.get_peg_count()
                if remaining > 1:
                    self.lbl_status.config(
                        text=f"D&C finished â€“ {remaining} pegs remain")
                return
            
            # Not over yet â€“ re-scan for more moves from the new state
            self.lbl_status.config(text="Auto: planning next moves...")
            self.searching = True
            # We can re-use the solver instance since it reads current game state
            self.solver.start_solving(callback=self._on_autoplay_solution)
            return
        move = self.autoplay_moves[self.autoplay_index]
        # Verify move is still legal (safety)
        if move not in self.game.get_legal_moves():
            self.autoplay_running = False
            self.btn_auto.config(text="Autoplay")
            messagebox.showerror("Autoplay Error","Solution invalid â€“ board state changed.")
            return
        self.game.execute_move(move)
        self.draw_board()
        self.autoplay_index += 1
        self.after(500, self.run_autoplay_step)

if __name__ == "__main__":
    root = tk.Tk()
    app = PegSolitaireApp(root)
    root.mainloop()
